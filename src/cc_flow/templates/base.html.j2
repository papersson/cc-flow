<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code - Session Flow</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+3:wght@400;500;600&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* highlight.js github-dark theme (inlined) */
        {{ hljs_github_dark_min_css | safe }}
    </style>
    <style>
        :root {
            /* Anthropic/Claude palette */
            --bg: #1a1714;
            --bg-subtle: #211e1a;
            --surface: #292420;
            --surface-raised: #332e28;
            --border: #3d3630;
            --border-focus: #5c4f42;

            --text: #f5f0eb;
            --text-secondary: #b8a99a;
            --text-muted: #7a6b5c;

            --coral: #d97757;
            --coral-dim: #a85a42;
            --coral-glow: rgba(217, 119, 87, 0.15);

            --sand: #c9a87c;
            --sand-dim: #8a7454;

            --sage: #7ca87c;
            --sage-glow: rgba(124, 168, 124, 0.12);

            --sky: #7ca8c9;
            --sky-glow: rgba(124, 168, 201, 0.12);

            --lavender: #a87cc9;
            --lavender-glow: rgba(168, 124, 201, 0.12);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Source Sans 3', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        /* Subtle texture */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background:
                radial-gradient(circle at 20% 20%, rgba(217, 119, 87, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(124, 168, 124, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        #nav-bar {
            position: fixed;
            top: 0; left: 0; right: 0;
            height: 52px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 16px;
            z-index: 100;
        }

        .nav-logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-logo svg {
            width: 24px;
            height: 24px;
            fill: var(--coral);
        }

        .nav-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text);
            letter-spacing: -0.01em;
        }

        .nav-sep {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        #breadcrumb {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }

        .breadcrumb-item {
            color: var(--text-secondary);
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 6px;
            transition: all 0.15s;
        }

        .breadcrumb-item:hover {
            background: var(--surface-raised);
            color: var(--text);
        }

        .breadcrumb-item.current {
            background: var(--coral-glow);
            color: var(--coral);
            cursor: default;
        }

        .breadcrumb-sep {
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        #controls {
            margin-left: auto;
            display: flex;
            gap: 6px;
        }

        #controls button {
            padding: 6px 14px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--surface-raised);
            color: var(--text-secondary);
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            transition: all 0.15s;
        }

        #controls button:hover {
            border-color: var(--coral-dim);
            color: var(--coral);
            background: var(--coral-glow);
        }

        #canvas-container {
            position: absolute;
            top: 52px; left: 0; right: 0; bottom: 32px;
            overflow: hidden;
            cursor: grab;
            z-index: 1;
        }

        #canvas-container:active { cursor: grabbing; }
        #canvas { position: absolute; transform-origin: 0 0; }

        /* Segment headers */
        .segment-header {
            position: absolute;
            padding: 10px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .segment-header.original {
            border-color: var(--sky);
            background: var(--sky-glow);
        }

        .segment-header.continuation {
            border-color: var(--lavender);
            background: var(--lavender-glow);
        }

        .segment-label {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .segment-header.original .segment-label { color: var(--sky); }
        .segment-header.continuation .segment-label { color: var(--lavender); }

        .segment-meta {
            font-family: 'Source Code Pro', monospace;
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        /* Turn cards */
        .turn-card {
            position: absolute;
            width: 440px;
            max-height: 600px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition:
                width 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 0.3s ease-out,
                border-color 0.2s,
                transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            cursor: pointer;
        }

        .turn-card:hover {
            border-color: var(--border-focus);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        /* Modal overlay */
        .modal-backdrop {
            position: fixed;
            top: 52px;
            left: 0;
            right: 0;
            bottom: 32px;
            background: rgba(26, 23, 20, 0.75);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 400;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease-out;
        }

        .modal-backdrop.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Expanded card modal */
        .card-modal {
            position: fixed;
            top: 52px;
            left: 0;
            right: 0;
            bottom: 32px;
            z-index: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.25s ease-out;
        }

        .card-modal.visible {
            pointer-events: auto;
            opacity: 1;
        }

        .card-modal-content {
            width: 100%;
            max-width: 900px;
            height: 100%;
            max-height: calc(100vh - 140px);
            background: var(--surface);
            border: 1px solid var(--border-focus);
            border-radius: 12px;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card-modal.visible .card-modal-content {
            transform: scale(1);
        }

        .modal-header {
            padding: 14px 18px;
            background: var(--surface-raised);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .modal-time {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .modal-actions {
            display: flex;
            gap: 8px;
        }

        .modal-btn {
            background: none;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 6px 10px;
            font-size: 0.8rem;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .modal-btn:hover {
            border-color: var(--coral-dim);
            color: var(--coral);
        }

        .modal-btn.copied {
            border-color: var(--sage);
            color: var(--sage);
        }

        .modal-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .modal-close {
            font-size: 1.4rem;
            line-height: 1;
            padding: 4px 10px;
        }

        .modal-user-section {
            padding: 18px 24px;
            background: var(--bg-subtle);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            max-height: 30vh;
            overflow-y: auto;
        }

        .modal-user-label {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--sand);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
        }

        .modal-user-section.system-msg {
            background: var(--bg);
            border-left: 3px solid var(--text-muted);
        }

        .modal-user-section.system-msg .modal-user-label {
            color: var(--text-muted);
        }

        .modal-user-message {
            font-size: 0.95rem;
            line-height: 1.65;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .modal-response {
            flex: 1;
            overflow-y: auto;
            padding: 18px 24px;
            scrollbar-width: thin;
            scrollbar-color: var(--border-focus) transparent;
        }

        .modal-response::-webkit-scrollbar { width: 8px; }
        .modal-response::-webkit-scrollbar-track { background: transparent; }
        .modal-response::-webkit-scrollbar-thumb { background: var(--border-focus); border-radius: 4px; }

        /* Modal blocks - cleaner typography hierarchy */
        .modal-block {
            margin-bottom: 16px;
        }

        .modal-block:last-child { margin-bottom: 0; }

        /* Text blocks - most prominent, minimal decoration */
        .modal-block.text {
            background: transparent;
            padding: 0 0 16px 0;
        }

        .modal-block.text .modal-block-header {
            display: none;
        }

        /* Thinking blocks - de-emphasized, collapsed by default */
        .modal-block.thinking {
            opacity: 0.85;
            padding: 12px 16px;
            background: var(--bg);
            border-radius: 6px;
            cursor: pointer;
        }

        .modal-block.thinking .modal-block-header {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .modal-block.thinking .modal-block-header::before {
            content: '▶';
            font-size: 0.6rem;
            transition: transform 0.15s;
        }

        .modal-block.thinking.expanded .modal-block-header::before {
            transform: rotate(90deg);
        }

        .modal-block.thinking .modal-block-content {
            max-height: 0;
            overflow: hidden;
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 0;
            opacity: 0;
            transition: max-height 0.2s ease-out, margin-top 0.2s ease-out, opacity 0.2s ease-out;
        }

        .modal-block.thinking.expanded .modal-block-content {
            max-height: 500px;
            margin-top: 8px;
            opacity: 1;
        }

        .modal-block.thinking .expand-link {
            display: none;
        }

        .modal-block.thinking.expanded .expand-link {
            display: inline-block;
            margin-top: 8px;
        }

        /* Tool groups - terminal-style with left accent */
        .modal-tool-group {
            margin-bottom: 20px;
            background: var(--bg);
            border-radius: 6px;
            padding: 12px 14px;
            border-left: 3px solid var(--border-focus);
        }

        .modal-tool-group:last-child { margin-bottom: 0; }

        .modal-tool-header {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 8px;
        }

        .modal-tool-group .modal-tool-input {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text);
        }

        .modal-tool-group .modal-tool-result {
            padding-top: 10px;
            margin-top: 10px;
            border-top: 1px solid var(--border);
            font-family: 'Source Code Pro', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-secondary);
        }

        .modal-tool-group .expand-container {
            padding-top: 8px;
        }

        /* Expand link for truncated content */
        .expand-link {
            color: var(--coral);
            font-size: 0.8rem;
            cursor: pointer;
            margin-top: 8px;
            display: inline-block;
            font-family: 'Source Code Pro', monospace;
        }

        .expand-link:hover {
            text-decoration: underline;
        }

        /* Subagent drill button in tool group */
        .modal-tool-group .drill-btn {
            margin: 12px 14px;
        }

        /* Legacy modal-block styles for standalone blocks */
        .modal-block-header {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 10px;
        }

        .modal-block-content {
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .modal-block-content.markdown h1,
        .modal-block-content.markdown h2,
        .modal-block-content.markdown h3 {
            margin: 0.5em 0 0.3em;
            font-weight: 600;
        }
        .modal-block-content.markdown h1 { font-size: 1.3em; }
        .modal-block-content.markdown h2 { font-size: 1.15em; }
        .modal-block-content.markdown h3 { font-size: 1em; }
        .modal-block-content.markdown p { margin: 0.5em 0; }
        .modal-block-content.markdown ul, .modal-block-content.markdown ol { margin: 0.5em 0; padding-left: 1.5em; }
        .modal-block-content.markdown li { margin: 0.2em 0; }
        .modal-block-content.markdown code {
            background: var(--bg);
            padding: 0.15em 0.4em;
            border-radius: 3px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.9em;
        }
        .modal-block-content.markdown pre {
            background: var(--bg);
            padding: 0.8em;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5em 0;
        }
        .modal-block-content.markdown pre code {
            background: none;
            padding: 0;
        }

        .modal-tool-input {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            padding: 12px;
            background: var(--bg);
            border-radius: 6px;
            border: 1px solid var(--border);
            margin-top: 10px;
        }

        .turn-header {
            padding: 10px 14px;
            background: var(--surface-raised);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .turn-time {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .copy-btn {
            background: none;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 6px;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .copy-btn:hover {
            border-color: var(--coral-dim);
            color: var(--coral);
        }

        .copy-btn.copied {
            border-color: var(--sage);
            color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .user-message {
            padding: 14px 16px;
            background: var(--bg-subtle);
            border-bottom: 1px solid var(--border);
            font-size: 0.9rem;
            line-height: 1.6;
            max-height: 150px;
            overflow: hidden;
            position: relative;
            flex-shrink: 0;
        }

        .user-message.truncated::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(transparent, var(--bg-subtle));
            pointer-events: none;
        }

        .user-label {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.65rem;
            font-weight: 500;
            color: var(--sand);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
        }

        .turn-card.system-message .user-message {
            background: var(--bg);
            border-left: 3px solid var(--text-muted);
        }

        .turn-card.system-message .user-label {
            color: var(--text-muted);
        }

        .response-items {
            padding: 12px;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-focus) transparent;
        }

        .response-items::-webkit-scrollbar { width: 6px; }
        .response-items::-webkit-scrollbar-track { background: transparent; }
        .response-items::-webkit-scrollbar-thumb { background: var(--border-focus); border-radius: 3px; }

        .response-item {
            margin-bottom: 6px;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            background: var(--bg);
        }

        .response-item:last-child { margin-bottom: 0; }

        /* Compact items (thinking, tools) - just header */
        .response-item.compact {
            padding: 6px 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .response-item.compact .item-header {
            margin-bottom: 0;
        }

        /* Text items - show content */
        .item-text {
            background: transparent;
            padding: 4px 0;
        }

        .item-header {
            font-family: 'Source Code Pro', monospace;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.65rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        .item-header::before {
            content: '▸';
            font-size: 0.6rem;
        }

        .item-text .item-header {
            display: none;
        }

        .item-content {
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.55;
        }

        /* Markdown rendering */
        .item-content.markdown h1,
        .item-content.markdown h2,
        .item-content.markdown h3 {
            margin: 0.5em 0 0.3em;
            font-weight: 600;
        }
        .item-content.markdown h1 { font-size: 1.3em; }
        .item-content.markdown h2 { font-size: 1.15em; }
        .item-content.markdown h3 { font-size: 1em; }
        .item-content.markdown p { margin: 0.5em 0; }
        .item-content.markdown ul, .item-content.markdown ol { margin: 0.5em 0; padding-left: 1.5em; }
        .item-content.markdown li { margin: 0.2em 0; }
        .item-content.markdown code {
            background: var(--bg);
            padding: 0.15em 0.4em;
            border-radius: 3px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.9em;
        }
        .item-content.markdown pre {
            background: var(--bg);
            padding: 0.8em;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5em 0;
        }
        .item-content.markdown pre code {
            background: none;
            padding: 0;
        }
        .item-content.markdown blockquote {
            border-left: 3px solid var(--border-focus);
            padding-left: 1em;
            margin: 0.5em 0;
            color: var(--text-secondary);
        }
        .item-content.markdown a {
            color: var(--coral);
            text-decoration: none;
        }
        .item-content.markdown a:hover {
            text-decoration: underline;
        }

        .drill-btn {
            margin-top: 10px;
            padding: 8px 14px;
            background: var(--coral-glow);
            color: var(--coral);
            border: 1px solid var(--coral-dim);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.15s;
        }

        .drill-btn:hover {
            background: var(--coral-dim);
            color: var(--text);
        }

        svg.edges {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            overflow: visible;
        }

        .edge {
            fill: none;
            stroke: var(--border-focus);
            stroke-width: 2;
        }

        .segment-divider {
            position: absolute;
            top: 0;
            bottom: 0;
            border-left: 2px dashed var(--border-focus);
            opacity: 0.5;
        }

        #status-bar {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            height: 32px;
            background: var(--surface);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            z-index: 100;
            gap: 24px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--sage);
        }

        /* Empty state message */
        .empty-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
            font-size: 1.1rem;
        }
        .empty-message h2 {
            color: var(--text-secondary);
            margin-bottom: 0.5em;
            font-weight: 500;
        }

        /* Unavailable subagent indicator */
        .subagent-unavailable {
            color: var(--text-muted);
            font-style: italic;
            font-size: 0.8rem;
            padding: 8px;
            background: var(--bg);
            border-radius: 4px;
            margin-top: 8px;
        }

    </style>
</head>
<body>
    <div id="nav-bar">
        <div class="nav-logo">
            <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
            <span class="nav-title">cc-flow</span>
        </div>
        <span class="nav-sep">|</span>
        <div id="breadcrumb">
            <span class="breadcrumb-item current">Session</span>
        </div>
        <div id="controls">
            <button onclick="resetView()">Reset</button>
            <button onclick="zoomIn()">+</button>
            <button onclick="zoomOut()">-</button>
        </div>
    </div>

    <div id="canvas-container">
        <div id="canvas"><svg class="edges"></svg></div>
    </div>

    <div id="status-bar">
        <div class="status-item">
            <span class="status-dot"></span>
            <span id="segment-count">0 segments</span>
        </div>
        <div class="status-item">
            <span id="turn-count">0 turns</span>
        </div>
        <div class="status-item">
            <span id="zoom-level">100%</span>
        </div>
        <div class="status-item" style="margin-left: auto;">
            drag to pan | scroll to zoom | click card to expand
        </div>
    </div>

    <div id="modal-backdrop" class="modal-backdrop"></div>
    <div id="card-modal" class="card-modal">
        <div class="card-modal-content">
            <div class="modal-header">
                <span class="modal-time" id="modal-time"></span>
                <div class="modal-actions">
                    <button class="modal-btn" id="modal-copy-btn">
                        <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                        Copy
                    </button>
                    <button class="modal-btn modal-close" id="modal-close-btn">&times;</button>
                </div>
            </div>
            <div class="modal-user-section" id="modal-user-section">
                <div class="modal-user-label" id="modal-user-label">Human</div>
                <div class="modal-user-message" id="modal-user-message"></div>
            </div>
            <div class="modal-response" id="modal-response"></div>
        </div>
    </div>

    <script>{{ marked_min_js | safe }}</script>
    <script>{{ highlight_min_js | safe }}</script>
    <script>
        // Configure marked
        marked.setOptions({
            breaks: true,
            gfm: true,
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    return hljs.highlight(code, { language: lang }).value;
                }
                return hljs.highlightAuto(code).value;
            }
        });

        const data = {{ session_json | safe }};
        const segments = data.segments;
        const subagents = data.subagents;

        let currentView = 'root';
        let navigationStack = ['root'];

        const CARD_WIDTH = 440, CARD_GAP_Y = 45, BRANCH_GAP_X = 500;
        const SEGMENT_GAP = 560;
        const PADDING = 60, HEADER_HEIGHT = 50;

        let scale = 1, translateX = PADDING, translateY = PADDING;
        let isDragging = false, dragStartX, dragStartY;

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }

        function formatTokens(n) {
            if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(0) + 'K';
            return n.toString();
        }

        const COPY_ICON = '<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
        const CHECK_ICON = '<svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';

        function copyTurnContent(turnKey, btn) {
            const turn = turnDataMap[turnKey];
            if (!turn) return;

            let text = `Human: ${turn.user_message}\n\n`;
            turn.blocks.forEach(block => {
                if (block.type === 'text') {
                    text += `${block.content}\n\n`;
                } else if (block.type === 'tool_use') {
                    text += `[Tool: ${block.tool_name}] ${block.tool_input}\n\n`;
                }
            });

            navigator.clipboard.writeText(text).then(() => {
                btn.classList.add('copied');
                btn.innerHTML = CHECK_ICON;
                setTimeout(() => {
                    btn.classList.remove('copied');
                    btn.innerHTML = COPY_ICON;
                }, 2000);
            });
        }

        function navigateTo(viewId) {
            if (viewId === 'root') {
                currentView = 'root';
                navigationStack = ['root'];
            } else if (subagents[viewId]) {
                const idx = navigationStack.indexOf(viewId);
                if (idx >= 0) {
                    navigationStack = navigationStack.slice(0, idx + 1);
                } else {
                    navigationStack.push(viewId);
                }
                currentView = viewId;
            }
            resetView();
            render();
            updateBreadcrumb();
        }

        function updateBreadcrumb() {
            const bc = document.getElementById('breadcrumb');
            bc.innerHTML = navigationStack.map((id, i) => {
                const isLast = i === navigationStack.length - 1;
                const label = id === 'root' ? 'Session' : `Agent ${id.substring(0,7)}`;
                const sep = i < navigationStack.length - 1 ? '<span class="breadcrumb-sep">></span>' : '';
                return `<span class="breadcrumb-item ${isLast ? 'current' : ''}" onclick="navigateTo('${id}')">${label}</span>${sep}`;
            }).join('');
        }

        function renderMarkdown(text) {
            try {
                return marked.parse(text);
            } catch (e) {
                return escapeHtml(text);
            }
        }

        function createTurnCard(turn, localIndex, segmentId, segmentType) {
            const card = document.createElement('div');
            card.className = 'turn-card' + (turn.is_system ? ' system-message' : '');
            card.dataset.turnId = `${segmentId}:${turn.id}`;
            card.dataset.segmentType = segmentType;
            const timestamp = turn.user_timestamp ? turn.user_timestamp.substring(11, 19) : '';
            const messageLabel = turn.is_system ? 'System' : 'Human';

            let itemsHtml = '';
            turn.blocks.forEach(item => {
                // Skip tool_result in card preview - shown in modal
                if (item.type === 'tool_result') return;

                if (item.type === 'thinking') {
                    // Compact: just header
                    itemsHtml += `<div class="response-item compact"><div class="item-header">Thinking</div></div>`;
                } else if (item.type === 'text') {
                    // Text: show content
                    itemsHtml += `
                        <div class="response-item item-text">
                            <div class="item-header">Text</div>
                            <div class="item-content markdown">${renderMarkdown(item.content)}</div>
                        </div>`;
                } else if (item.type === 'tool_use') {
                    // Compact: just tool name
                    const toolName = item.tool_name + (item.subagent_type ? ` (${item.subagent_type})` : '');
                    let drillBtn = '';
                    if (item.child_agent_id && subagents[item.child_agent_id]) {
                        drillBtn = `<button class="drill-btn" onclick="event.stopPropagation();navigateTo('${item.child_agent_id}')" style="margin-left:auto;padding:4px 8px;font-size:0.65rem;">Enter</button>`;
                    }
                    itemsHtml += `<div class="response-item compact"><div class="item-header">${toolName}</div>${drillBtn}</div>`;
                }
            });

            const turnKey = `${segmentId}:${turn.id}`;

            card.innerHTML = `
                <div class="turn-header">
                    <span class="turn-time">${timestamp}</span>
                    <button class="copy-btn" onclick="event.stopPropagation();copyTurnContent('${turnKey}', this)">${COPY_ICON}</button>
                </div>
                <div class="user-message">
                    <div class="user-label">${messageLabel}</div>
                    ${escapeHtml(turn.user_message)}
                </div>
                ${itemsHtml ? `<div class="response-items">${itemsHtml}</div>` : ''}
            `;
            return card;
        }

        function createSegmentHeader(segment) {
            const header = document.createElement('div');
            header.className = `segment-header ${segment.type}`;

            let label, meta = '';
            if (segment.type === 'continuation') {
                label = 'Continued';
                const tokens = segment.compact_metadata?.pre_tokens || 0;
                if (tokens) meta = `${formatTokens(tokens)} tokens compacted`;
            } else {
                label = 'Original';
                meta = `${segment.turns.length} turns`;
            }

            header.innerHTML = `
                <span class="segment-label">${label}</span>
                <span class="segment-meta">${meta}</span>
            `;
            return header;
        }

        function render() {
            const canvas = document.getElementById('canvas');
            canvas.querySelectorAll('.turn-card, .segment-header, .empty-message, .segment-divider').forEach(el => el.remove());

            let allPositions = {};
            let allHeights = {};
            let totalTurns = 0;
            turnDataMap = {}; // Clear turn data on re-render

            // Handle empty state
            if (currentView === 'root' && segments.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'empty-message';
                emptyMsg.innerHTML = '<h2>No conversation found</h2><p>The session file contains no user messages.</p>';
                canvas.appendChild(emptyMsg);
                document.getElementById('segment-count').textContent = '0 segments';
                document.getElementById('turn-count').textContent = '0 turns';
                return;
            }

            if (currentView === 'root') {
                // Render segments side by side
                let segmentX = 0;

                segments.forEach((segment, segIdx) => {
                    const turns = segment.turns;
                    totalTurns += turns.length;

                    // Create segment header
                    const headerEl = createSegmentHeader(segment);
                    headerEl.style.position = 'absolute';
                    headerEl.style.left = segmentX + 'px';
                    headerEl.style.top = '0px';
                    canvas.appendChild(headerEl);

                    // Measure card heights
                    const heights = {};
                    turns.forEach((turn, i) => {
                        const card = createTurnCard(turn, i, segment.id, segment.type);
                        canvas.appendChild(card);
                        heights[turn.id] = card.offsetHeight;
                        card.remove();
                    });

                    // Layout this segment
                    const positions = {};
                    const turnById = {};
                    turns.forEach(t => turnById[t.id] = t);

                    const roots = turns.filter(t => t.parent_turn_id === null);
                    let localX = segmentX;

                    function layoutSubtree(turnId, x, y) {
                        const turn = turnById[turnId];
                        if (!turn) return { width: 0, height: 0 };
                        const posKey = `${segment.id}:${turnId}`;
                        positions[posKey] = { x, y, segmentId: segment.id, turnId: turnId };
                        const children = turns.filter(t => t.parent_turn_id === turnId);
                        if (children.length === 0) return { width: CARD_WIDTH, height: heights[turnId] };
                        let childY = y + heights[turnId] + CARD_GAP_Y;
                        let totalWidth = 0;
                        children.forEach((child, i) => {
                            const childX = x + totalWidth;
                            const subtree = layoutSubtree(child.id, childX, childY);
                            totalWidth += subtree.width + (i < children.length - 1 ? BRANCH_GAP_X - CARD_WIDTH : 0);
                        });
                        return { width: Math.max(CARD_WIDTH, totalWidth), height: heights[turnId] };
                    }

                    let maxWidth = 0;
                    roots.forEach(root => {
                        layoutSubtree(root.id, localX, HEADER_HEIGHT);
                        const maxX = Math.max(...Object.values(positions).filter(p => p.segmentId === segment.id).map(p => p.x));
                        localX = maxX + CARD_WIDTH + BRANCH_GAP_X;
                        maxWidth = Math.max(maxWidth, maxX + CARD_WIDTH - segmentX);
                    });

                    // Render cards for this segment
                    turns.forEach((turn, i) => {
                        const card = createTurnCard(turn, i, segment.id, segment.type);
                        const posKey = `${segment.id}:${turn.id}`;
                        const pos = positions[posKey];
                        if (pos) {
                            card.style.left = pos.x + 'px';
                            card.style.top = pos.y + 'px';
                        }
                        storeTurnData(segment.id, turn);
                        canvas.appendChild(card);
                    });

                    Object.assign(allPositions, positions);
                    Object.assign(allHeights, heights);

                    // Add segment divider (except after last segment)
                    if (segIdx < segments.length - 1) {
                        const dividerX = segmentX + maxWidth + SEGMENT_GAP / 2;
                        const divider = document.createElement('div');
                        divider.className = 'segment-divider';
                        divider.style.left = dividerX + 'px';
                        canvas.appendChild(divider);
                    }

                    segmentX += maxWidth + SEGMENT_GAP;
                });

                document.getElementById('segment-count').textContent = `${segments.length} segments`;
                document.getElementById('turn-count').textContent = `${totalTurns} turns`;

            } else {
                // Render subagent
                const turns = subagents[currentView] || [];
                totalTurns = turns.length;
                const subagentSegmentId = 'subagent';

                const heights = {};
                turns.forEach((turn, i) => {
                    const card = createTurnCard(turn, i, subagentSegmentId, 'subagent');
                    canvas.appendChild(card);
                    heights[turn.id] = card.offsetHeight;
                    card.remove();
                });

                const positions = {};
                const turnById = {};
                turns.forEach(t => turnById[t.id] = t);
                const roots = turns.filter(t => t.parent_turn_id === null);

                let globalX = 0;
                function layoutSubtree(turnId, x, y) {
                    const turn = turnById[turnId];
                    if (!turn) return { width: 0, height: 0 };
                    const posKey = `${subagentSegmentId}:${turnId}`;
                    positions[posKey] = { x, y, segmentId: subagentSegmentId, turnId: turnId };
                    const children = turns.filter(t => t.parent_turn_id === turnId);
                    if (children.length === 0) return { width: CARD_WIDTH, height: heights[turnId] };
                    let childY = y + heights[turnId] + CARD_GAP_Y;
                    let totalWidth = 0;
                    children.forEach((child, i) => {
                        const childX = x + totalWidth;
                        const subtree = layoutSubtree(child.id, childX, childY);
                        totalWidth += subtree.width + (i < children.length - 1 ? BRANCH_GAP_X - CARD_WIDTH : 0);
                    });
                    return { width: Math.max(CARD_WIDTH, totalWidth), height: heights[turnId] };
                }

                roots.forEach(root => {
                    layoutSubtree(root.id, globalX, 0);
                    const maxX = Math.max(...Object.values(positions).map(p => p.x), 0);
                    globalX = maxX + CARD_WIDTH + BRANCH_GAP_X;
                });

                turns.forEach((turn, i) => {
                    const card = createTurnCard(turn, i, subagentSegmentId, 'subagent');
                    const posKey = `${subagentSegmentId}:${turn.id}`;
                    const pos = positions[posKey];
                    if (pos) { card.style.left = pos.x + 'px'; card.style.top = pos.y + 'px'; }
                    storeTurnData(subagentSegmentId, turn);
                    canvas.appendChild(card);
                });

                Object.assign(allPositions, positions);
                Object.assign(allHeights, heights);

                document.getElementById('segment-count').textContent = `subagent`;
                document.getElementById('turn-count').textContent = `${totalTurns} turns`;
            }

            // Draw edges
            const svg = document.querySelector('svg.edges');
            svg.innerHTML = '';
            let maxX = 0, maxY = 0;
            Object.values(allPositions).forEach(p => {
                maxX = Math.max(maxX, p.x + CARD_WIDTH);
                maxY = Math.max(maxY, p.y + 500);
            });
            svg.setAttribute('width', Math.max(maxX + PADDING, 100));
            svg.setAttribute('height', Math.max(maxY + PADDING, 100));

            // Flatten turns with segment context for composite key lookups
            const allTurns = currentView === 'root'
                ? segments.flatMap(s => s.turns.map(t => ({ ...t, _segmentId: s.id })))
                : (subagents[currentView] || []).map(t => ({ ...t, _segmentId: 'subagent' }));

            allTurns.forEach(turn => {
                if (turn.parent_turn_id === null) return;
                const parentPosKey = `${turn._segmentId}:${turn.parent_turn_id}`;
                const childPosKey = `${turn._segmentId}:${turn.id}`;
                const parentPos = allPositions[parentPosKey], childPos = allPositions[childPosKey];
                if (!parentPos || !childPos) return;
                const parentCard = document.querySelector(`[data-turn-id="${parentPosKey}"]`);
                const parentHeight = parentCard ? parentCard.offsetHeight : 200;
                const x1 = parentPos.x + CARD_WIDTH / 2, y1 = parentPos.y + parentHeight;
                const x2 = childPos.x + CARD_WIDTH / 2, y2 = childPos.y;
                const midY = (y1 + y2) / 2;
                const pathD = `M ${x1} ${y1} C ${x1} ${midY}, ${x2} ${midY}, ${x2} ${y2}`;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'edge');
                path.setAttribute('d', pathD);
                svg.appendChild(path);
            });

            // Detect and apply truncation to user messages
            document.querySelectorAll('.turn-card .user-message').forEach(el => {
                if (el.scrollHeight > 150) {
                    el.classList.add('truncated');
                }
            });

            updateTransform();
        }

        function updateTransform() {
            document.getElementById('canvas').style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            document.getElementById('zoom-level').textContent = `${Math.round(scale * 100)}%`;
        }

        function resetView() { scale = 1; translateX = PADDING; translateY = PADDING; updateTransform(); }
        function zoomIn() { scale = Math.min(scale * 1.2, 3); updateTransform(); }
        function zoomOut() { scale = Math.max(scale / 1.2, 0.2); updateTransform(); }

        // Modal functions
        let currentModalTurn = null;

        // Group tool_use blocks with their corresponding tool_result
        function groupBlocks(blocks) {
            const groups = [];
            const resultMap = new Map();

            // Index tool_results by tool_use_id
            blocks.filter(b => b.type === 'tool_result' && b.tool_use_id)
                  .forEach(b => resultMap.set(b.tool_use_id, b));

            const usedResults = new Set();

            blocks.forEach(block => {
                if (block.type === 'tool_use') {
                    const result = resultMap.get(block.tool_use_id);
                    groups.push({
                        groupType: 'tool',
                        toolUse: block,
                        toolResult: result || null
                    });
                    if (result) usedResults.add(block.tool_use_id);
                } else if (block.type === 'tool_result') {
                    // Skip if already paired
                    if (!usedResults.has(block.tool_use_id)) {
                        groups.push({ groupType: 'standalone', block });
                    }
                } else {
                    groups.push({ groupType: 'standalone', block });
                }
            });

            return groups;
        }

        function openModal(turn) {
            currentModalTurn = turn;

            // Populate modal content
            const timestamp = turn.user_timestamp ? turn.user_timestamp.substring(11, 19) : '';
            document.getElementById('modal-time').textContent = timestamp;

            const userSection = document.getElementById('modal-user-section');
            const userLabel = document.getElementById('modal-user-label');
            const userMessage = document.getElementById('modal-user-message');

            userLabel.textContent = turn.is_system ? 'System' : 'Human';
            userMessage.textContent = turn.user_message;

            if (turn.is_system) {
                userSection.classList.add('system-msg');
            } else {
                userSection.classList.remove('system-msg');
            }

            // Build response blocks using grouping
            const responseEl = document.getElementById('modal-response');
            let blocksHtml = '';

            if (turn.blocks && turn.blocks.length > 0) {
                const groups = groupBlocks(turn.blocks);
                let thinkingCounter = 0;

                groups.forEach((group) => {
                    if (group.groupType === 'tool') {
                        // Render unified tool group
                        const toolUse = group.toolUse;
                        const toolResult = group.toolResult;
                        const toolName = toolUse.tool_name + (toolUse.subagent_type ? ` (${toolUse.subagent_type})` : '');

                        let inputContent = escapeHtml(toolUse.tool_input);
                        let expandInputLink = '';
                        if (toolUse.is_truncated && toolUse.full_content) {
                            expandInputLink = `<span class="expand-link" data-block-id="${toolUse.tool_use_id}" data-content-type="input">[Show all]</span>`;
                        }

                        let resultContent = '';
                        let expandResultLink = '';
                        if (toolResult) {
                            resultContent = escapeHtml(toolResult.content);
                            if (toolResult.is_truncated && toolResult.full_content) {
                                expandResultLink = `<span class="expand-link" data-block-id="${toolResult.tool_use_id}" data-content-type="result">[Show all]</span>`;
                            }
                        }

                        let drillBtn = '';
                        if (toolUse.child_agent_id) {
                            if (subagents[toolUse.child_agent_id]) {
                                drillBtn = `<button class="drill-btn" onclick="closeModal();navigateTo('${toolUse.child_agent_id}')">Enter subagent</button>`;
                            } else {
                                drillBtn = `<div class="subagent-unavailable" style="margin: 12px 14px;">Subagent data unavailable</div>`;
                            }
                        }

                        blocksHtml += `
                            <div class="modal-tool-group">
                                <div class="modal-tool-header">${toolName}</div>
                                <div class="modal-tool-input" data-block-id="${toolUse.tool_use_id}" data-content-type="input">${inputContent}</div>
                                ${expandInputLink ? `<div class="expand-container">${expandInputLink}</div>` : ''}
                                ${toolResult ? `
                                    <div class="modal-tool-result" data-block-id="${toolResult.tool_use_id}" data-content-type="result">${resultContent}</div>
                                    ${expandResultLink ? `<div class="expand-container">${expandResultLink}</div>` : ''}
                                ` : ''}
                                ${drillBtn}
                            </div>
                        `;
                    } else {
                        // Render standalone block
                        const block = group.block;

                        if (block.type === 'thinking') {
                            let content = escapeHtml(block.content);
                            let expandLink = '';
                            const thinkingId = `thinking-${thinkingCounter++}`;
                            if (block.is_truncated && block.full_content) {
                                expandLink = `<span class="expand-link" data-thinking-id="${thinkingId}">[Show all]</span>`;
                            }
                            blocksHtml += `
                                <div class="modal-block thinking" data-thinking-id="${thinkingId}" onclick="this.classList.toggle('expanded')">
                                    <div class="modal-block-header">Thinking</div>
                                    <div class="modal-block-content">${content}</div>
                                    ${expandLink}
                                </div>
                            `;
                        } else if (block.type === 'text') {
                            blocksHtml += `
                                <div class="modal-block text">
                                    <div class="modal-block-header">Text</div>
                                    <div class="modal-block-content markdown">${renderMarkdown(block.content)}</div>
                                </div>
                            `;
                        } else if (block.type === 'tool_result') {
                            // Standalone tool_result (orphaned)
                            let content = escapeHtml(block.content);
                            let expandLink = '';
                            if (block.is_truncated && block.full_content) {
                                expandLink = `<span class="expand-link" data-block-id="${block.tool_use_id}" data-content-type="orphan-result">[Show all]</span>`;
                            }
                            blocksHtml += `
                                <div class="modal-tool-group">
                                    <div class="modal-tool-header">Result</div>
                                    <div class="modal-tool-result" data-block-id="${block.tool_use_id}" data-content-type="orphan-result">${content}</div>
                                    ${expandLink ? `<div class="expand-container">${expandLink}</div>` : ''}
                                </div>
                            `;
                        }
                    }
                });
            }

            responseEl.innerHTML = blocksHtml;

            // Add expand link handlers (toggle between truncated and full)
            responseEl.querySelectorAll('.expand-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const blockId = link.dataset.blockId;
                    const contentType = link.dataset.contentType;
                    const thinkingId = link.dataset.thinkingId;
                    const isExpanded = link.dataset.expanded === 'true';

                    if (thinkingId) {
                        // Handle thinking block content toggle
                        const thinkingBlock = turn.blocks.find(b => b.type === 'thinking' && b.is_truncated);
                        if (thinkingBlock) {
                            const thinkingEl = responseEl.querySelector(`[data-thinking-id="${thinkingId}"]`);
                            if (thinkingEl) {
                                const contentEl = thinkingEl.querySelector('.modal-block-content');
                                if (contentEl) {
                                    if (isExpanded) {
                                        contentEl.textContent = thinkingBlock.content;
                                        link.textContent = '[Show all]';
                                        link.dataset.expanded = 'false';
                                    } else {
                                        contentEl.textContent = thinkingBlock.full_content;
                                        link.textContent = '[Show less]';
                                        link.dataset.expanded = 'true';
                                    }
                                }
                            }
                        }
                    } else if (blockId && contentType) {
                        // Handle tool input/result toggle
                        let block;
                        if (contentType === 'input') {
                            block = turn.blocks.find(b => b.type === 'tool_use' && b.tool_use_id === blockId);
                        } else {
                            block = turn.blocks.find(b => b.type === 'tool_result' && b.tool_use_id === blockId);
                        }

                        if (block) {
                            const contentEl = responseEl.querySelector(`[data-block-id="${blockId}"][data-content-type="${contentType}"]`);
                            if (contentEl) {
                                if (isExpanded) {
                                    contentEl.textContent = contentType === 'input' ? block.tool_input : block.content;
                                    link.textContent = '[Show all]';
                                    link.dataset.expanded = 'false';
                                } else if (block.full_content) {
                                    contentEl.textContent = block.full_content;
                                    link.textContent = '[Show less]';
                                    link.dataset.expanded = 'true';
                                }
                            }
                        }
                    }
                });
            });

            // Show modal
            document.getElementById('modal-backdrop').classList.add('visible');
            document.getElementById('card-modal').classList.add('visible');
        }

        function closeModal() {
            document.getElementById('modal-backdrop').classList.remove('visible');
            document.getElementById('card-modal').classList.remove('visible');
            currentModalTurn = null;
        }

        function copyModalContent() {
            if (!currentModalTurn) return;

            let text = `Human: ${currentModalTurn.user_message}\n\n`;
            currentModalTurn.blocks.forEach(block => {
                if (block.type === 'text') {
                    text += `${block.content}\n\n`;
                } else if (block.type === 'tool_use') {
                    text += `[Tool: ${block.tool_name}] ${block.tool_input}\n\n`;
                }
            });

            const btn = document.getElementById('modal-copy-btn');
            navigator.clipboard.writeText(text).then(() => {
                btn.classList.add('copied');
                btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> Copied';
                setTimeout(() => {
                    btn.classList.remove('copied');
                    btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg> Copy';
                }, 2000);
            });
        }

        // Modal event listeners
        document.getElementById('modal-backdrop').addEventListener('click', closeModal);
        document.getElementById('card-modal').addEventListener('click', (e) => {
            // Close if clicking the modal container (outside the content)
            if (e.target === e.currentTarget) closeModal();
        });
        document.getElementById('modal-close-btn').addEventListener('click', closeModal);
        document.getElementById('modal-copy-btn').addEventListener('click', copyModalContent);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeModal();
        });

        // Store turn data for copy/lookup
        let turnDataMap = {};

        function storeTurnData(segmentId, turn) {
            const key = `${segmentId}:${turn.id}`;
            turnDataMap[key] = turn;
        }

        const container = document.getElementById('canvas-container');

        container.addEventListener('mousedown', (e) => {
            if (e.target.closest('.turn-card, .segment-header')) return;
            isDragging = true;
            dragStartX = e.clientX - translateX;
            dragStartY = e.clientY - translateY;
        });

        container.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            translateX = e.clientX - dragStartX;
            translateY = e.clientY - dragStartY;
            updateTransform();
        });

        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);

        // Card click handler - open modal
        container.addEventListener('click', (e) => {
            const card = e.target.closest('.turn-card');
            if (!card) return;
            // Skip if clicking interactive elements
            if (e.target.closest('button, .drill-btn')) return;

            const turnKey = card.dataset.turnId;
            const turn = turnDataMap[turnKey];
            if (turn) {
                openModal(turn);
            }
        });

        container.addEventListener('wheel', (e) => {
            if (e.target.closest('.response-items')) return;
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.2, Math.min(3, scale * delta));
            const rect = container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;
            translateX = mouseX - (mouseX - translateX) * (newScale / scale);
            translateY = mouseY - (mouseY - translateY) * (newScale / scale);
            scale = newScale;
            updateTransform();
        });

        render();
    </script>
</body>
</html>
